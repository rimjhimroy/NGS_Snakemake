#############
##  Maker  ##
#############

import os, subprocess
import configparser
from Maker import *

# Set some basic variables (snakemake doesn't always allow these calls directly in rules)
maker_out = ".".join(CONFIG["maker_opts"]["genome"].split(".")[:-1]) + ".output"


""" use this rule to clean-up maker settings """
rule clean_maker:
    shell: "rm -f " + CONFIG['base']['working_dir'] + "/maker_*.ctl " + CONFIG['base']['working_dir'] + "/maker_done.txt"

""" use this rule to clean-up all the data produced by maker """
rule clean_data:
    shell: "rm -rf " + CONFIG['base']['working_dir']

rule clean_perl:
    shell: "rm -rf " + CONFIG["base"]["perl_install"]

# Install maker dependancies :

# Create .bashrc to store settings and paths
rule maker_bashrc:
    output : CONFIG['base']['maker_bashrc']
    params : dir = strip_path_level(CONFIG['base']['maker_bashrc'],1)
    shell :
        "mkdir -p {params.dir} && "
        "touch {output}"

# Download and install Augustus
rule augustus_installation:
    input: rules.maker_bashrc.output
    output: CONFIG["executables"]["augustus"]
    params: dir = strip_path_level(CONFIG["executables"]["augustus"],2)
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['augustus_URL']+";"
        "tar xzf augustus*;"
        "rm *.tar.*;"
        "mv  augustus*/* {params.dir};"
        "rmdir augustus*;"
        "touch {output} && "
        "echo 'export PATH='`readlink -f {params.dir}/bin/`':$PATH' >> {input} ;"
        "echo 'export AUGUSTUS_CONFIG_PATH='`readlink -f {params.dir}/config/`  >> {input} ;"
        "cd / && rmdir $TEMPDIR;"

# Download and install Exonerate
rule exonerate_installation:
    input: rules.maker_bashrc.output
    output: CONFIG["executables"]["exonerate"]
    params: dir = strip_path_level(CONFIG["executables"]["exonerate"],2)
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['exonerate_URL']+";"
        "tar xzf exonerate*;"
        "rm *.tar.*;"
        "mv exonerate*/* {params.dir};"
        "rmdir exonerate*;"
        "touch {output} && "
        "echo 'export PATH='`readlink -f {params.dir}/bin/`':$PATH' >> {input} ;"
        "cd / && rmdir $TEMPDIR;"

# Download and install SNAP
rule snap_installation:
    input: rules.maker_bashrc.output
    output: CONFIG["executables"]["snap"]
    params: dir = strip_path_level(CONFIG["executables"]["snap"],1)
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['snap_URL']+";"
        "tar xzf snap*;"
        "rm *.tar.*;"
        "mv snap*/* {params.dir};"
        "touch {output} && "
        "cd {params.dir} && make;"
        "echo 'export ZOE='`readlink -f {params.dir}` >> {input} ;"
        "echo 'export PATH='`readlink -f {params.dir}`':$PATH' >> {input} ;"
        "cd / && rm -rf $TEMPDIR;"

# Download and install TRF
rule trf_installation:
    input: rules.maker_bashrc.output
    output: CONFIG["executables"]["trf"]
    params: dir = strip_path_level(CONFIG["executables"]["trf"],1)
    shell:
        "mkdir -p {params.dir} && "
        "cd {params.dir} && "
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['trf_URL']+" && "
        "mv trf* {output} && "
        "chmod a+x {output} && "
        "touch {output} && "
        "echo 'export PATH='`readlink -f {params.dir}`':$PATH' >> {input} ;"

# Download and install BLAST+
rule blast_plus_installation:
    input: rules.maker_bashrc.output
    output: CONFIG["executables"]["blastn"]
    params: dir = strip_path_level(CONFIG["executables"]["blastn"],2)
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['blast+_URL']+" && "
        "tar xzf ncbi* && "
        "rm *.tar.* && "
        "mv ncbi*/* {params.dir} && rmdir ncbi* && "
        "touch {output} && "
        "echo 'export PATH='`readlink -f {params.dir}/bin`':$PATH' >> {input} ;"
        "cd / && rmdir $TEMPDIR;"

# Download and install RMBLAST plus corresponding BLAST+
rule rmblast_installation:
    output: CONFIG["executables"]["rmblast"]
    params: dir = strip_path_level(CONFIG["executables"]["rmblast"],2)
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['rmblast_URL']+" && "
        "tar xzf ncbi-blast* && "
        "tar xzf ncbi-rmblast* && "
        "rm  *.tar.* && "
        "cp -R ncbi-rmblast*/* ncbi-blast*/ && "
        "cp -R ncbi-blast*/* {params.dir} && "
        "touch {output} && "
        "cd / && rm -rf $TEMPDIR;"

# Download and install GIRI RepBase
rule repbase_installation:
    output: CONFIG["executables"]["repbase"]
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR && "
        "curl --remote-name --anyauth --netrc-file "+CONFIG['executable_sources']['repeatmaskerlibraries_URL_netrc']+" "+CONFIG['executable_sources']['repeatmaskerlibraries_URL']+" && "
        "tar xzf repeatmaskerlibraries* && "
        "cp -R Libraries {output} && "
        "cp -R repeatmaskerlibraries* {output} && "
        "touch {output} && "
        "cd / && rm -rf $TEMPDIR;"

# Download and install Repeatmasker
rule repeatmasker_installation:
    input:
        REPBASE=rules.repbase_installation.output,
        RMBLAST=rules.rmblast_installation.output,
        TRF=rules.trf_installation.output,
        BASHRC=rules.maker_bashrc.output
    output: CONFIG["executables"]["RepeatMasker"]
    params: dir = strip_path_level(CONFIG["executables"]["RepeatMasker"],1), RMBLAST = strip_path_level(CONFIG["executables"]["rmblast"],1)
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['repeatmasker_URL']+" && "
        "tar xzf RepeatMasker-open-* && "
        "rm *.tar.* && "
        "mv RepeatMasker*/* {params.dir} && "
        "cd {params.dir} && grep -l -r '#!/u1' * | xargs -I '%' sed -i 's|/u1/local/bin/perl|/usr/bin/env perl|' % && "
        "cp RepeatMaskerConfig.tmpl RepeatMaskerConfig.pm && chmod -x RepeatMaskerConfig.pm && "
        'sed -i \'s|DEFAULT_SEARCH_ENGINE\s\+=.*|DEFAULT_SEARCH_ENGINE = "ncbi";|\' RepeatMaskerConfig.pm && '
        'sed -i \'s|TRF_PRGM\s\+=.*|TRF_PRGM = "' + "{input.TRF}" + '";|\' RepeatMaskerConfig.pm && '
        'sed -i \'s|RMBLAST_DIR\s\+=.*|RMBLAST_DIR = "' + "{params.RMBLAST}" + '";|\' RepeatMaskerConfig.pm && '
        "cp {input.REPBASE}Libraries/RepeatMaskerLib.embl Libraries/ ; "
        "echo 'export PATH='`readlink -f {params.dir}`':$PATH' >> {input.BASHRC} && "
        "cd / && rm -rf $TEMPDIR;"
        "touch {output} && "

# Install perl if version is too low (as on our cluster)
rule install_perl:
    input: rules.maker_bashrc.output
    output: CONFIG["executables"]["perl"]
    params: dir = strip_path_level(CONFIG["executables"]["perl"],2)
    shell:
        "if [ `echo $(perl -e 'print $];')'>5.018' | bc` != '1' ];"
        "then "
            "TEMPDIR=`mktemp -d` && "
            "cd $TEMPDIR && "
            "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['perl_URL']+" && "
            "tar xzf ActivePerl-5* && "
            "cd ActivePerl-5* && "
            "rm -rf {params.dir} && "
            "sh install.sh --prefix={params.dir} --no-install-html --license-accepted && "
            "cd - && "
            "rm -rf ActivePerl-5* && "
            "cd / && rm -rf $TEMPDIR &&"
            "touch {output} && "
            "echo 'export PATH='`readlink -f {params.dir}`':$PATH' >> {input} && "
            "touch {output};"
        "else "
            "ln -s `which perl` {output};"
        "fi;"

# Create local Perl library
rule install_perl_locallib:
    input:
        BASHRC=rules.maker_bashrc.output,
        PERL=rules.install_perl.output
    output: CONFIG["base"]["perl_install"] + "bin/cpanm"
    shell:
        "source {input.BASHRC};"
        "mkdir -p " + CONFIG["base"]["perl_install"] + "bin && "
        "cd "+ CONFIG["base"]["perl_install"] + "bin && "
        "wget --no-check-certificate http://xrl.us/cpanm && "
        "chmod +x cpanm && "
        "locallib_LATEST=` curl -s ftp://ftp.cpan.org/pub/CPAN/authors/id/A/AP/APEIRON/ | grep --perl-regexp --ignore-case --only-matching \"local-lib.*?.gz\" "
        " | sort --ignore-case --version-sort  | tail -1` && "
        "wget ftp://ftp.cpan.org/pub/CPAN/authors//id/A/AP/APEIRON/${{locallib_LATEST}} && "
        "tar -xzf ${{locallib_LATEST}} && "
        "cd $(basename `echo ${{locallib_LATEST}}` .tar.gz) && "
        "{input.PERL} Makefile.PL --bootstrap && "
        "make test && make install && make clean && "
        "echo 'eval $({input.PERL} -I$HOME/perl5/lib/perl5 -Mlocal::lib)' >> {input.BASHRC} && "
        "touch {output}"

# Install necessary Perl libraries
rule perl_libs:
    input:
        rules.install_perl_locallib.output,
        rules.install_perl.output,
        BASHRC=rules.maker_bashrc.output
    output: CONFIG["base"]["perl_install"] + "lib/done"
    run:
        for lib in CONFIG["base"]["perl_libs"]:
            shell("source  {input.BASHRC} ; " + CONFIG["base"]["perl_install"] + "bin/cpanm --skip-satisfied --self-contained --force --notest " + lib)
        shell("touch " + CONFIG["base"]["perl_install"] + "lib/done")

#  Download and install Maker
# TODO : Fix output handling, this is ugly

rule maker_installation:
    input:
        rules.repeatmasker_installation.output,
        rules.blast_plus_installation.output,
        rules.snap_installation.output,
        rules.exonerate_installation.output,
        rules.augustus_installation.output,
        rules.perl_libs.output,
        BASHRC=rules.maker_bashrc.output
    params: dir = strip_path_level(CONFIG["executables"]["maker"],2)
    output: CONFIG["executables"]["maker"]
    shell:
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget"+CONFIG['executable_sources']['wget_options']+CONFIG['executable_sources']['maker_URL']+" && "
        "tar xzf maker* && "
        "rm maker*.tgz && "
        "touch maker && "
        "cp --recursive maker/* {params.dir} && "
        "cd / && rm -rf $TEMPDIR;"
        "cd {params.dir}/src && source {input.BASHRC} && "
        "perl Build.PL && "
        "./Build install && "
        "touch --no-dereference {output} && "

""" create the maker_bopts.ctl file """
rule maker_bopts:
    input: rules.maker_installation.output
    params : configured = read_maker_opts_ctl(CONFIG["maker_bopts"], "maker_bopts.ctl.conf")
    output: CONFIG['base']['working_dir'] + "/maker_bopts.ctl"
    shell:
        'cd ' + CONFIG['base']['working_dir'] + ' && '
        '{input} -BOPTS && '
        'echo -e "{params.configured}" | grep -v "\[maker\]" > {output}'

""" create the maker_opts.ctl file """
rule maker_opts:
    input: rules.maker_installation.output
    params : configured = read_maker_opts_ctl(CONFIG["maker_opts"], "maker_opts.ctl.conf")
    output: CONFIG['base']['working_dir'] + "/maker_opts.ctl"
    shell:
        'cd ' + CONFIG['base']['working_dir'] + ' && '
        '{input} -OPTS && '
        'echo -e "{params.configured}" | grep -v "\[maker\]" > {output}'

""" create the maker_exe.ctl file """
rule maker_exe:
    input: rules.maker_installation.output
    params : configured = read_maker_opts_ctl(CONFIG["executables"], "maker_exe.ctl.conf")
    output: CONFIG['base']['working_dir']+ "/maker_exe.ctl"
    shell:
        'cd ' + CONFIG['base']['working_dir'] + ' && '
        '{input} -EXE && '
        'echo -e "{params.configured}" | grep -v "\[maker\]" > {output}'

"""" rule to run maker based on the given configuration """
rule maker:
    input:
        rules.maker_bopts.output,
        rules.maker_opts.output,
        rules.maker_exe.output,
        MAKER=rules.maker_installation.output,
        BASHRC=rules.maker_bashrc.output
    output: CONFIG['base']['working_dir'] + "/maker_done.txt"
    shell: 'cd ' + CONFIG['base']['working_dir'] + ' && '
           "source {input.BASHRC} && "
           '{input.MAKER} &&'
           'touch ' + CONFIG['base']['working_dir'] + '/maker_done.txt'

rule copy_gffs:
    input: rules.maker.output
    output: CONFIG['base']['working_dir'] + "/gffs"
    shell: 'cd ' + CONFIG['base']['working_dir'] + ' && '
        "mkdir -p gffs && "
        "MAKER_OUTPUT=`find . -type d -wholename '*maker.output'` && "
        "MAKER_PREFIX=`basename $MAKER_OUTPUT .maker.output` && "
        "find $MAKER_OUTPUT -maxdepth 5 -type f -iname '*gff' | xargs -I{{}} cp {{}} gffs"

# Rule to concatenate all generated GFFs
rule concatenate_gffs:
    input: GFFs = rules.copy_gffs.output
    output: CONFIG['base']['working_dir'] + "/concatenated.gff"
    shell: 'cd {input.GFFs} && '
           "touch ../concatenated.gff && "
           "ls *.gff | xargs cat >> ../concatenated.gff "


# Get all predicted proteins:
rule get_predicted_proteins:
    input: rules.maker.output
    output: CONFIG['base']['working_dir'] + "/predicted_proteins.faa"
    shell: "cd " + CONFIG['base']['working_dir'] +  "  && "
        "MAKER_OUTPUT=`find . -type d -wholename '*maker.output'` && "
        "touch  predicted_proteins.faa && "
        "find $MAKER_OUTPUT -type f -iname '*maker.proteins.fasta' | xargs cat >> predicted_proteins.faa"


# pretty-print names from maker prediction
rule create_id_mapping_file:
    input: rules.concatenate_gffs.output
    output: CONFIG['base']['working_dir'] + "/ids.map"
    shell: "cd " +CONFIG['base']['working_dir']+ "  && "
        "" + CONFIG['base']['maker_perl'] + "maker_map_ids --prefix '" + CONFIG['output']['protein_prefix'] + "' --justify 8 concatenated.gff > ids.map"

rule rename_ids_gff:
    input:
        rules.create_id_mapping_file.output,
        rules.copy_gffs.output,
        GFF = glob_wildcards(CONFIG['base']['working_dir'] + "/gffs/{gff}.gff")

    output: CONFIG['base']['working_dir'] + "/gffs/renamed{gff}.txt"
    shell: "cd " + CONFIG['base']['working_dir']+ " && "
        "" + CONFIG['base']['maker_perl'] + "map_gff_ids ids.map {input.GFF}.gff"


#rule rename_proteins:
#    input: rules.id_mapping_file,
#        rules.get_predicted_proteins

""" FUNCTIONAL ANNOTATION """

rule install_interproscan:
    input: rules.maker_bashrc.output
    output: CONFIG["functional_annotation"]["interproscan"]
    shell:
        "source {input} && "
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget " + CONFIG["functional_annotation"]["interproscan_url"] + " && "
        "tar zxvf *.gz && "
        "mkdir -p {output} && "
        "mv -v */* {output} && "
        "cd - && rm -rf $TEMPDIR;"

rule install_panther:
    input:
        INTERPRO=rules.install_interproscan.output,
        BASHRC=rules.maker_bashrc.output
    output: CONFIG["functional_annotation"]["interproscan"] + "/data/panther"
    shell:
        "source {input.BASHRC} && "
        "cd {input.INTERPRO}/data && "
        "wget " + CONFIG["functional_annotation"]["panther_url"] + " && "
        "tar zxvf panther*.gz && touch " + CONFIG["functional_annotation"]["interproscan"] + "/data/panther && "
        "rm panther*.gz"


rule install_uniprot:
    input: rules.maker_bashrc.output
    output: CONFIG["functional_annotation"]["uniprot"]
    shell:
        "source {input} && "
        "TEMPDIR=`mktemp -d`;"
        "cd $TEMPDIR;"
        "wget -m -R 'xml.gz' " + CONFIG["functional_annotation"]["uniprot_url"] + " && "
        "gunzip -vk uniref100.fasta.gz && "
        'TITLE="UniRef100 - "`cat uniref100.release_note | grep Release | sed \'s/^[ \\t]*//\'` && '
        '' + CONFIG["executables"]['makeblastdb'] + ' -in uniref100.fasta -dbtype prot -out uniref -title "$TITLE" -parse_seqids && '
        "mkdir -p {output} && "
        "mv -v * {output} && "
        "cd - && rm -rf $TEMPDIR;"

rule interproscan:
    input:
        INTERPRO = rules.install_interproscan.output,
        PROTEINS = rules.get_predicted_proteins.output
    output: CONFIG['base']['working_dir'] + "/protein_annotation.tsv"
    shell: "{input.INTERPRO}/interproscan.sh -i {input.PROTEINS} -f tsv -o {output}"

rule uniprot:
    input:
        UNIPROT = rules.install_uniprot.output,
        PROTEINS = rules.get_predicted_proteins.output
    output: CONFIG['base']['working_dir'] + "/protein_uniprot.csv"
    shell: CONFIG["executables"]['blastp'] + " -out {output}"
        "-num_threads 4 -outformat 7 "
        "-max_target_seqs 1 "
        "-query {input.PROTEINS} "
        "-db {input.UNIPROT}/uniref"
